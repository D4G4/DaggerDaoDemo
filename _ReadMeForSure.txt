DaggerDaoDemo 
    -developement steps

GRADLE DEPENDENCIES:

#For Dagger
	compile "com.google.dagger:dagger:2.8"
	provided 'javax.annotation:jsr250-api:1.0'
	compile 'javax.inject:javax.inject:1'
	annotationProcessor "com.google.dagger:dagger-compiler:2.8"
    
Note:We are using the annotation processor provided by gradle for android.
Dagger-compiler is the annotation processing repo for generating the dependency graph classes during build time.

#For GreenDao
    compile 'org.greenrobot:greendao:3.2.2'
    
    //For database encryption
    compile 'net.zetetic:android-database-sqlcipher:3.5.7'
    
------------------------------------------------------------------------------X-------------------------------------------------------------------------
    
CREATE PACKAGES:
    data -> model,converter
    di   -> component, module
    
------------------------------------------------------------------------------X-------------------------------------------------------------------------
   
CREATE CUSOM ANNOTATIONS:
    1. @interface ActivityContext.java         -> @Quantifier
    2. @interface AppContext.java              -> @Quantifier
    3. @interface DatabaseInfo.java            -> @Quantifier 
    4. @interface PerActivity.java             -> @Scope
    
    @Quantifier is used to distinguish b/w the objects of same type but with different instances
    @Scope -> If a class getting dependencies, have MEMBERS INJECTED with classes annotated with scope,
              then each instance of that class asking for dependencies will get it's OWN SET OF member variables.
    @interface is used instead of normal 'interface'. This tells dagger that the current class is a custom annotation.           
    
------------------------------------------------------------------------------X-------------------------------------------------------------------------

CREATE ENUM:
    We are creating a java ENUM of Genders to show the usage of custom
    org.greenrobot.greendao.converter.PropertyConverter
    thats it.
    
    But what are PropertyConverter?
    Well to add support for a custom type, you can map them to one of the supported types 
    using a @Convert annotation. 
    You also need to provide a PropertyConverter implementation.
    
    For example: 
    You could define a color in your entity using a custom Color class and map it to an Integer. 
    Or you can map the popular org.joda.time.DateTime from Joda Time to a Long.

------------------------------------------------------------------------------X-------------------------------------------------------------------------

CREATE DATABASE CLASS (Users.java):

        @Entity(indexes = { @Index(value ="id,name ASEC", unique = true)})
        Wait what?
        This annotation is provided by GreenDao. Now with this annotation, GreenDao figures out that this class is intended to be a table.
        As per the documentation: To use greenDAO in a project, you can create an entity model representing the presistent(permanent) data in your application.
        Then, based on this model, greenDAO generates Java code for the DAO (Data Access Object) classes.
        The model(generated by GreenDao) itself is defined using Java classes with annotations.
        
        So the @Entity annotation turns the Java class `User` into a database-backend entity. This will also instruct greenDAO to generate the necessary code.
        Note: only Java classes are supported. If you prefer another language like Kotlin, your entity classes must still be Java.
        
        
        While it is usually fine to go without any additional parameters, you can still configure some details using @Entity:
        
         @Entity(
            // If you have more than one schema, you can tell greenDAO
            // to which schema an entity belongs to (pick any string as a name)
            schema = "mySchema",
            
            // Flag to make an entity "active": Active entities have update, delete and refresh methods.
            active = true,
            
            // Specifies the name of the table in the database.
            // By default, the name is based on the entitie's class name
            nameInDb = "AWESOME_NAME",
            
            //Define indexes spanning multiple columns here. (when one has to perform a quick search)
            indexes = {
                        @Index(value = "name, someOtherColumn DESC", unique = true)      //Now this unique attribute will work on the combination of all the values
            },
            
            // Flag is the DAO should create the database table (default is true)
            // Set this to false, if you have multiple entries mapping to one table,
            // or the table creation is done outside of greenDAO.
            createInDb = false,
            
            // Whether an all properties constructor should be generated.
            // A no-args constructor is always required.
            generateConstructos = true,
            
            // Whether getters and setters for properties should be generated if missing
            generateGettersSetters = true
        )
        public class User{
            ...
        }
            
------------------------------------------------------------------------------X-------------------------------------------------------------------------    
    
BASIC PROPERTIES (GREEN DAO)
    #1  The @Id annotation selects a long/Long property as the entity ID. In database terms, it's a primary key. 
        The parameter, autoincrement is a flag to make the ID value every increasing.
       
    #2  @Property lets you define a non-default column name, which the property is mapped to.
        If absent, greenDAO will use the field name in a SQL-ish fashion (upper case, underscores instead of camel case, 
        for example customName will become CUSTOM_NAME).
        
    #3  @NotNull makes the property a "NOT NULL" column on the database side. Usually it makes sense to mark primitvie types(long,int,short,byte)
        with @NotNull, while having nullable values with wrapper classes(Long,Integer,Short,Byte).
          
    #4  @Transient marks properties to be excluded frrom presistence. Use those from temporary states, etc.
        Alternatively, you can use the `transient` keywoard from java.
        
    PRIMARY KEY RESTRICTIONS
    Currently, entities must have a long or Long property as their primary key. This is recommended practice for Android and SQLite.
          
    To workaround(method for overcoming problem) this, define your key property as an additional property, but create a unnique index for it:
                    @Id
                    private Long id;
                    
                    @Index(unique = true)
                    private String key;
    
    
    PROPERTY INDEXES
    
    use @Index at a property to create a database index for the corresponding database column. 
    Use the following parameters to customize:
    
        > name: If you do not like the defauly name greenDAO generates for the index, you can specify yours here.
        > unique: Adds a UNIQUE constraint to the index, forcing all values to be unique.
                    
                    @Entity
                    public class User {
                            @Id private Long id;
                            @Unique private String name;
                    }
          
          
     DEFAULTS
     
        GreenDAO tries to work with reasonable defaults, so developers don’t have to configure each and every bit.
        For example the table and column name on the database side are derived from the entity and property names. 
        Instead of the camel case style used in Java, the default database names are in uppercase using an underscore to separate word.
        For example, a property called creationDate will become a database column CREATION_DATE.     
          
------------------------------------------------------------------------------X-------------------------------------------------------------------------

TRIGGERING GENERATION
      
     Once your entity schema is in place, you can trigger the code generation process by using “Make project” in your IDE. 
     Or by directly executing the greendao Gradle task.
     If you encounter errors after changing your entity classes, try to rebuild your project to make sure old generated classes are cleaned.    
          
    Also, in your build.gradle (app), add these:
    
    apply plugin: 'com.android.application'
    apply plugin: 'org.greenrobot.greendao'
    
    in another build.gradle, add a gradle plugin
    
    And under your dependencies{
     classpath 'org.greenrobot:greendao-gradle-plugin:3.2.2'
    }
          
------------------------------------------------------------------------------X-------------------------------------------------------------------------

CREATE DatabaseHelper.java

    In this class, we are going to initialize DaoSession and will add helper methods for our DB interaction.

    but first, make a DbOpenHelper.class        @Singleton
  
            This class extends DaoMaster.OpenHelper         
            
            We use @Inject annotation to it's constructor(required) which has following Arguments
            > @ApplicationContext Context context
            > @DatabaseInfo String name
            
    Please note: In the GreenDao's official tutorial(notes), you may find use usage of DaoMaster.DevOpenHelper instead of DaoMaster.OpenHelper
    
        The former(DevOpenHelper) is GreenDao's generated DaoMaster class.
        
                public static abstract class OpenHelper extends SQLiteOpenHelper {
                
                    public OpenHelper(Context context, String name, CursorFactory factory) {
                        super(context, name, factory, SCHEMA_VERSION);
                    }

                    @Override
                    public void onCreate(SQLiteDatabase db) {
                        createAllTables(db, false);
                    }
                }

                /** WARNING: Drops all table on Upgrade! Use only during development. */
                public static class DevOpenHelper extends OpenHelper {
                
                    public DevOpenHelper(Context context, String name, CursorFactory factory) {
                        super(context, name, factory);
                    }

                    @Override
                    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
                        dropAllTables(db, true);
                        onCreate(db);
                    }
               }

    Coming back to DatabaseHelper.java

    > Mark it as @Singleton to ensure a single instance of a class globally, so there will be only one DatabaseHelper
    > We have used a boolean value -> Encrypted which can be changed at any point of time
    
    > Use @Inject on the constructor which uses DbOpenHelper as it's argument to initialize DaoSession (this will be done by Dagger)
    
    > Create helper methods.
        In order to fetch the list of all the records from DB, use `loadAll()`
    

    TL;DR       -> The only purpose of this class is to provide DAO Session.

------------------------------------------------------------------------------X-------------------------------------------------------------------------

DataManager.java        @Singleton

    This class expresses the dependencies of Application's
        > @ApplicationContext Context
        > DatabaseHelper
        in it's constructor. It provides all the apis to access the data in the application.

    Now we will @Inject the instance of this call into our activities and use the methods to interact with DatabaseHelper's methods.
    Think of it as a middle man ;)
    
------------------------------------------------------------------------------X-------------------------------------------------------------------------

Now let's hold on for some time and review the Dagger2

> To provide the dependency for a class(DataManager.java in this case) we have to create a Module class. This class
  defines the methods that provide the dependency.
  A module class is identified by @Module and the dependency provider method is identified by @Provides.
  
> We then have to create an interface (ApplicationComponent) that serves as a connection between a class (MvpApp.java)
  that expresses the dependency through @Inject and a class that provides the dependency i.e. annotated with @Module.
  
> In order to figure out the dependencies that a Module has to provide, we have to scan all the classes in the graph that needs 
  to be provided with the dependencies and then figure out the least number of objects that has to be provided.


------------------------------------------------------------------------------X-------------------------------------------------------------------------

MvpApp.java
    
    Define this class under <Application> 
    
    @Inject DataManager
    

------------------------------------------------------------------------------X-------------------------------------------------------------------------
We have to provide the dependencies expressed in the MvpApp class. This class needs DataManager and to provide this class
we have to provide The dependencies expressed by DataManager, which as mentioned in constructor.
        DataManager
                   -> ApplicationContext
                   -> DatabaseHelper
                            -> DbOpenHelper 
                                    -> AppContext
                                    -> DatabaseInfo
                                    
We now accumulate the superset of all these dependencies, which turn out to be: Context, dbName and version.

ApplicationModule.java

    What are Modules?
        It's a part of Dagger. They are Dependency provider. 
        Therefore, one has to create a separate module for every DependencyConsumer (Activity or Application class etc)
        A @Module annotated class defines a class that contributes to the dagger object graph.
        https://github.com/square/dagger/blob/master/core/src/main/java/dagger/Module.java

------------------------------------------------------------------------------X-------------------------------------------------------------------------

ApplicationComponent.java

ApplicationComponent is an interface that is IMPLEMENTED BY DAGGER2. 
Using @Component we specify the class to be a component.

Here we have written a method inject() where we pass the MvpApp instance. Why do we do it?

When the dependencies are provided through field injection i.e. @inject on the member variables,
we have to tell the Dagger to scan this class through the implementation of this interface.

This class also provides methods that are used to access the dependencies that exist in the dependency graph.

@Singleton
@Component(modules = ApplicationModule.class)
public interface ApplicationComponent{
    ...
}
          
          
          
          
          
          
          
          
          
          
          
          
    
